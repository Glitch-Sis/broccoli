<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sport Challenge App</title>
    <!-- Tailwind CSS CDN für das Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Konfiguration für Tailwind CSS -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6', // Blau
                        secondary: '#f59e0b', // Amber/Gelb für Warnungen
                        accent: '#22c55e', // Grün
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1f2937 0%, #0f172a 100%);
            color: #f3f4f6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }
        .card {
            transition: all 0.3s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1p x rgba(0, 0, 0, 0.06);
        }
        .progress-bar-fill {
            transition: width 0.5s ease-in-out;
        }
        .animate-pulse-slow {
            animation: pulse-slow 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse-slow {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: .5;
            }
        }
        .toast-container {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast {
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            color: white;
            opacity: 0;
            animation: fadeinout 4s forwards;
            min-width: 250px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .toast-success { background-color: #22c55e; }
        .toast-error { background-color: #f59e0b; }
        .toast-info { background-color: #3b82f6; }
        @keyframes fadeinout {
            0% { opacity: 0; transform: translateY(20px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        /* Custom style für den Soll-Marker */
        .target-marker {
            width: 3px; 
            background-color: #f59e0b; /* Amber/Gelb */
            box-shadow: 0 0 5px rgba(245, 158, 11, 0.8);
            z-index: 10;
            position: absolute;
            top: 0;
            bottom: 0;
            height: 100%;
        }
        /* Tooltip-Stil für die Sportarten-Liste */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }
        .tooltip-content {
            visibility: hidden;
            background-color: #334155;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 10;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal;
            max-width: 250px; 
        }
        .tooltip-container:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        /* Collapsible styles */
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
        }
        .collapsible-content-expanded {
            max-height: 9999px; /* Erhöht für Coach-Inhalt */
        }
        .toggle-icon {
            transition: transform 0.3s ease-in-out;
        }
        .toggle-icon-rotated {
            transform: rotate(180deg);
        }
        .collapsible-btn {
            cursor: pointer;
            text-align: left;
        }

    </style>

    <!-- Firebase JS SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        (async function() {
            // =====================================
            // Globale Variablen und UI-Elemente
            // =====================================
            
            const SPORT_WEIGHTS = {
                'Laufen': 1.5,
                'Schwimmen': 1.8,
                'Radfahren': 1.2,
                'Krafttraining': 1.3,
                'Yoga': 0.8,
                'Wandern': 0.9,
                'Step Aerobic': 1.6,
                'HIIT': 1.7,
                'Kayaking': 1.1,
                'Schwertkampf': 1.6, 
                'Taekwondo': 1.7,
                'Andere': 1.0
            };
            const STRENGTH_SPORTS = ['Krafttraining', 'HIIT', 'Schwertkampf', 'Taekwondo', 'Yoga']; // Liste der Kraftsportarten
            
            const GOAL_MINUTES = 8000;
            const WHO_GOAL_MINUTES = 15000; // Zweites Ziel (Maximales Ziel für Skalierung)

            // HARDCODED START DATE (Original Challenge Start)
            const GOAL_START_DATE = new Date('2025-09-01T00:00:00Z');

            const appContainer = document.getElementById('app-container');
            const modal = document.getElementById('message-modal');
            const modalContentWrapper = document.getElementById('modal-content-wrapper');
            const toastContainer = document.getElementById('toast-container');
            
            let userId;
            let currentUser;
            let displayedUserId;
            let myProgressView = 'minutes';
            let chartTimeframe = 'week';
            let allSports = { ...SPORT_WEIGHTS };
            let editingDocId = null;

            // Speichert die aktuell geladenen Daten
            let entries = [];
            let leaderboardParticipants = []; // Enthält jetzt die stabilen, sortierten Metriken
            let userEntriesCache = {}; // Cache für die Einträge anderer Benutzer
            // Hält das tatsächliche Startdatum der Challenge für den eingeloggten Benutzer
            let userChallengeStartDate = GOAL_START_DATE; 

            // =====================================
            // Firebase Konfiguration und Initialisierung
            // =====================================
            const firebaseConfigFromStorage = localStorage.getItem('firebaseConfig');
            const firebaseConfig = firebaseConfigFromStorage 
                ? JSON.parse(firebaseConfigFromStorage) 
                : (typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {});
            
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';
            
            let app = null;
            let auth = null;
            let db = null;
            
            if (firebaseConfig.projectId) {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
            }

            /** Zeigt das Modal zur Eingabe der Firebase-Konfiguration an */
            function showConfigModal() {
                modalContentWrapper.innerHTML = `
                    <div class="p-6">
                        <h3 class="text-xl font-bold text-primary mb-4">Firebase Konfiguration</h3>
                        <p class="text-slate-300 mb-4">Bitte geben Sie Ihre Firebase-Konfiguration als JSON ein, um fortzufahren.</p>
                        <textarea id="config-input" rows="10" class="w-full p-2 rounded-lg bg-slate-800 text-white border border-slate-600 focus:outline-none focus:ring-2 focus:ring-primary" placeholder="{
  &quot;apiKey&quot;: &quot;...&quot;,
  &quot;authDomain&quot;: &quot;...&quot;,
  &quot;projectId&quot;: &quot;...&quot;,
  &quot;storageBucket&quot;: &quot;...&quot;,
  &quot;messagingSenderId&quot;: &quot;...&quot;,
  &quot;appId&quot;: &quot;...&quot;
}"></textarea>
                        <button id="save-config-btn" class="w-full bg-primary text-white font-semibold py-3 rounded-lg hover:bg-blue-700 transition-colors mt-4">Speichern und neu laden</button>
                        <div id="config-error" class="text-secondary text-sm mt-2 hidden"></div>
                    </div>
                `;
                modal.classList.remove('hidden');

                document.getElementById('save-config-btn').addEventListener('click', () => {
                    const configInput = document.getElementById('config-input').value;
                    const errorEl = document.getElementById('config-error');
                    try {
                        const parsedConfig = JSON.parse(configInput);
                        localStorage.setItem('firebaseConfig', JSON.stringify(parsedConfig));
                        window.location.reload();
                    } catch (e) {
                        errorEl.textContent = 'Ungültiges JSON-Format. Bitte überprüfen Sie Ihre Eingabe.';
                        errorEl.classList.remove('hidden');
                    }
                });
            }
            
            /** Zeigt eine Toast-Benachrichtigung an */
            function showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.textContent = message;
                toastContainer.appendChild(toast);

                setTimeout(() => {
                    toast.remove();
                }, 4000);
            }

            /**
             * Kopiert Text in die Zwischenablage und zeigt eine Bestätigung an.
             * @param {string} text - Der zu kopierende Text.
             * @param {string} message - Die Bestätigungsnachricht.
             */
            function copyToClipboard(text, message) {
                const el = document.createElement('textarea');
                el.value = text;
                el.setAttribute('readonly', '');
                el.style.position = 'absolute';
                el.style.left = '-9999px';
                document.body.appendChild(el);
                el.select();
                document.execCommand('copy');
                document.body.removeChild(el);
                showToast(message, 'info');
            }

            // =====================================
            // Firebase-Datenbank-Funktionen
            // =====================================

            /**
             * Ruft die Sporteinträge eines Benutzers aus Firestore ab.
             * @param {string} uid - Die Benutzer-ID.
             */
            async function getSportEntries(uid) {
                if (!db) {
                    console.error("Firestore-Instanz ist nicht verfügbar.");
                    return [];
                }
                // Zugriff auf die private Sammlung des Benutzers
                const privateEntriesPath = `/artifacts/${appId}/users/${uid}/sportEntries`;
                const q = query(collection(db, privateEntriesPath));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach(doc => {
                    entries.push({ id: doc.id, ...doc.data() });
                });
                return entries;
            }

            /**
             * Fügt einen neuen Sporteintrag in Firestore hinzu.
             * @param {object} entry - Das hinzuzufügende Datenobjekt.
             */
            async function addSportEntry(entry) {
                if (!db) return;
                try {
                    const privateEntriesPath = `/artifacts/${appId}/users/${userId}/sportEntries`;
                    await addDoc(collection(db, privateEntriesPath), entry);
                    // Nach Hinzufügen: Leaderboard-Statistiken aktualisieren
                    await updateLeaderboardStats(userId, currentUser);
                    showToast("Sporteintrag hinzugefügt!", "success");
                    await loadAllData();
                } catch (e) {
                    console.error("Fehler beim Hinzufügen des Dokuments: ", e);
                    showToast("Fehler beim Hinzufügen des Eintrags.", "error");
                }
            }

            /**
             * Löscht einen Sporteintrag aus Firestore.
             * @param {string} docId - Die ID des zu löschenden Dokuments.
             */
            async function deleteSportEntry(docId) {
                if (!db) return;
                try {
                    const privateEntriesPath = `/artifacts/${appId}/users/${userId}/sportEntries`;
                    await deleteDoc(doc(db, privateEntriesPath, docId));
                    await updateLeaderboardStats(userId, currentUser);
                    showToast("Eintrag gelöscht.", "info");
                    await loadAllData();
                } catch (e) {
                    console.error("Fehler beim Löschen des Dokuments: ", e);
                    showToast("Fehler beim Löschen des Eintrags.", "error");
                }
            }
            
            /**
             * Aktualisiert einen bestehenden Sporteintrag in Firestore.
             * @param {string} docId - Die ID des zu aktualisierenden Dokuments.
             * @param {object} newEntry - Die aktualisierten Daten.
             */
            async function updateSportEntry(docId, newEntry) {
                if (!db) return;
                try {
                    const privateEntriesPath = `/artifacts/${appId}/users/${userId}/sportEntries`;
                    await updateDoc(doc(db, privateEntriesPath, docId), newEntry);
                    await updateLeaderboardStats(userId, currentUser);
                    showToast("Eintrag aktualisiert.", "success");
                    await loadAllData();
                } catch (e) {
                    console.error("Fehler beim Aktualisieren des Dokuments: ", e);
                    showToast("Fehler beim Aktualisieren des Eintrags.", "error");
                }
            }

            /**
             * Ruft benutzerdefinierte Sportarten aus Firestore ab.
             * @param {string} uid - Die Benutzer-ID.
             */
            async function getUserDefinedSports(uid) {
                if (!db) {
                    console.error("Firestore-instanz ist nicht verfügbar.");
                    return {};
                }
                const privateSportsPath = `/artifacts/${appId}/users/${uid}/userDefinedSports/sportsDoc`;
                const docRef = doc(db, privateSportsPath);
                const docSnap = await getDoc(docRef);
                // Gibt nur die benutzerdefinierten Sportarten zurück (ohne Standard-Sportarten)
                return docSnap.exists() ? docSnap.data().sports : {};
            }

            /**
             * Speichert benutzerdefinierte Sportarten in Firestore.
             * @param {object} sports - Das Objekt mit Sportarten und Gewichtungen (NUR benutzerdefinierte).
             */
            async function saveUserDefinedSports(sports) {
                if (!db) return;
                try {
                    const privateSportsPath = `/artifacts/${appId}/users/${userId}/userDefinedSports/sportsDoc`;
                    // Speichert nur die benutzerdefinierten Sportarten
                    await setDoc(doc(db, privateSportsPath), { sports });
                    
                    // allSports neu laden
                    allSports = { ...SPORT_WEIGHTS, ...sports };
                } catch (e) {
                    console.error("Fehler beim Speichern der Sportarten: ", e);
                    showToast("Fehler beim Speichern der Sportarten.", "error");
                }
            }

            /**
             * Ruft die Leaderboard-Daten aus Firestore ab (nur statische Minuten und Name).
             */
            async function getLeaderboard() {
                if (!db) {
                    console.error("Firestore-Instanz ist nicht verfügbar.");
                    return [];
                }
                const publicLeaderboardPath = `/artifacts/${appId}/public/data/leaderboard`;
                const q = query(collection(db, publicLeaderboardPath));
                const querySnapshot = await getDocs(q);
                const participants = [];
                querySnapshot.forEach(doc => {
                    participants.push({ id: doc.id, ...doc.data() });
                });
                return participants;
            }

            /**
             * Aktualisiert die Statistiken eines Benutzers im öffentlichen Leaderboard.
             * @param {string} uid - Die Benutzer-ID.
             * @param {string} nickname - Der Spitzname des Benutzers.
             */
            async function updateLeaderboardStats(uid, nickname) {
                if (!db) return;
                try {
                    const privateEntriesPath = `/artifacts/${appId}/users/${uid}/sportEntries`;
                    const q = query(collection(db, privateEntriesPath));
                    const querySnapshot = await getDocs(q);

                    let totalMinutes = 0;
                    let totalWeightedMinutes = 0;
                    const sportsData = allSports;

                    querySnapshot.forEach(doc => {
                        const entry = doc.data();
                        const weight = sportsData[entry.sport] || 1.0;
                        totalMinutes += entry.minutes;
                        totalWeightedMinutes += entry.minutes * weight;
                    });

                    const publicDocRef = doc(db, `/artifacts/${appId}/public/data/leaderboard`, uid);
                    await setDoc(publicDocRef, {
                        nickname: nickname,
                        minutes: totalMinutes,
                        weightedMinutes: totalWeightedMinutes,
                        lastUpdated: new Date()
                    }, { merge: true });

                } catch (e) {
                    console.error("Fehler beim Aktualisieren des Leaderboards:", e);
                }
            }

            /**
             * Ermittelt den Challenge-Zeitraum (Start- und Enddatum) basierend auf den Einträgen.
             * @param {Array<Object>} entries - Die Sporteinträge des Benutzers.
             * @returns {{startDate: Date, endDate: Date}}
             */
            function getChallengePeriod(entries) {
                const defaultStartDate = GOAL_START_DATE;
                let startDate = defaultStartDate;

                const validEntries = entries.filter(e => {
                    const date = e.timestamp.toDate ? e.timestamp.toDate() : new Date(e.timestamp);
                    return date >= defaultStartDate;
                });

                if (validEntries.length > 0) {
                    const minDate = validEntries.reduce((min, entry) => {
                        const date = entry.timestamp.toDate ? entry.timestamp.toDate() : new Date(entry.timestamp);
                        return date < min ? date : min;
                    }, new Date(validEntries[0].timestamp.toDate ? validEntries[0].timestamp.toDate() : new Date(validEntries[0].timestamp)));
                    
                    // Der Startpunkt ist der früheste Eintrag, jedoch nicht vor dem offiziellen Startdatum
                    startDate = minDate < defaultStartDate ? defaultStartDate : minDate;
                }
                
                // Das Challenge-Jahr endet 1 Jahr nach dem effektiven Startdatum
                const endDate = new Date(startDate);
                endDate.setFullYear(startDate.getFullYear() + 1);
                
                return { startDate, endDate };
            }
            
            /** Lädt alle notwendigen Daten aus der DB und aktualisiert die UI */
            async function loadAllData() {
                try {
                    appContainer.innerHTML = `<p class="text-center text-slate-400">Lade App-Daten...</p>`;
                    
                    // 1. Eigene Einträge und Sportarten laden
                    entries = await getSportEntries(userId);
                    userChallengeStartDate = getChallengePeriod(entries).startDate;
                    const userSports = await getUserDefinedSports(userId);
                    allSports = { ...SPORT_WEIGHTS, ...userSports };
                    
                    // 2. Rohdaten des Leaderboards laden
                    const rawParticipants = await getLeaderboard();
                    
                    // 3. NEU: Stabile Berechnung und Sortierung des Leaderboards
                    const stableLeaderboardData = [];
                    for (const p of rawParticipants) {
                        // Hole Einträge (entweder eigene, Cache oder fetch für Freunde)
                        let pEntries;
                        if (p.id === userId) {
                            pEntries = entries; // Eigene Einträge
                        } else if (userEntriesCache[p.id]) {
                            pEntries = userEntriesCache[p.id]; // Aus Cache
                        } else {
                            // Lade Einträge und cache sie für die Ranglistenberechnung (Startdatum-Ermittlung)
                            pEntries = await getSportEntries(p.id); 
                            userEntriesCache[p.id] = pEntries; 
                        }

                        // Berechne Challenge-Zeitraum basierend auf den Einträgen
                        const { startDate, endDate } = getChallengePeriod(pEntries); 

                        // Berechne Ratios
                        const { requiredProgressPercentage } = calculateRequiredProgress(GOAL_MINUTES, startDate, endDate);
                        const actualProgress = (p.minutes / GOAL_MINUTES) * 100;
                        const progressRatio = actualProgress - requiredProgressPercentage;

                        stableLeaderboardData.push({
                            ...p,
                            progressRatio: progressRatio,
                            // Speichere die zur Rangberechnung verwendeten Metriken
                            actualProgress: actualProgress,
                            requiredProgress: requiredProgressPercentage
                        });
                    }

                    // 4. Sortiere die finale Rangliste und speichere sie global
                    leaderboardParticipants = stableLeaderboardData.sort((a, b) => b.progressRatio - a.progressRatio);

                    renderApp();
                } catch (error) {
                    console.error("Fehler beim Laden der App-Daten: ", error);
                    showDynamicModal("Fehler", "Daten konnten nicht geladen werden. Bitte versuchen Sie es erneut.", [{ id: 'modal-close-btn', text: 'OK', class: 'w-full bg-primary text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition-colors', onClick: () => modal.classList.add('hidden') }]);
                }
            }


            // =====================================
            // UI Rendering und Update Funktionen
            // =====================================

            /**
             * Zeigt ein dynamisches modales Fenster mit anpassbarem Titel, Nachricht und Buttons an.
             * @param {string} title - Der Titel des Modals.
             * @param {string} message - Die Nachricht des Modals.
             * @param {Array<Object>} buttons - Ein Array von Button-Konfigurationsobjekten.
             */
            function showDynamicModal(title, message, buttons) {
                modalContentWrapper.innerHTML = `
                    <h3 class="text-xl font-bold mb-2 ${title.includes("Fehler") || title.includes("löschen") ? 'text-secondary' : 'text-primary'}">${title}</h3>
                    <p class="text-slate-300 mb-4">${message}</p>
                    <div class="flex justify-end gap-2 mt-4" id="modal-buttons"></div>
                `;
                modal.classList.remove('hidden');

                const buttonContainer = document.getElementById('modal-buttons');
                buttons.forEach(btnConfig => {
                    const button = document.createElement('button');
                    button.id = btnConfig.id;
                    button.textContent = btnConfig.text;
                    button.className = btnConfig.class;
                    button.addEventListener('click', btnConfig.onClick);
                    buttonContainer.appendChild(button);
                });
            }
            
            /** Rendert das Anmeldeformular für den Spitznamen. */
            function renderNicknameForm() {
                appContainer.innerHTML = `
                    <div class="text-center p-6 bg-slate-700 rounded-xl">
                        <h2 class="text-2xl font-semibold mb-4 text-white">Willkommen!</h2>
                        <p class="text-slate-300 mb-4">Geben Sie Ihren Spitznamen ein, um zu beginnen.</p>
                        <form id="nickname-form" class="space-y-4">
                            <input type="text" id="nickname-input" placeholder="Ihr Spitzname" class="w-full p-3 rounded-lg bg-slate-800 text-white border border-slate-600 focus:outline-none focus:ring-2 focus:ring-primary">
                            <button type="submit" class="w-full bg-primary text-white font-semibold py-3 rounded-lg hover:bg-blue-700 transition-colors">Starten</button>
                        </form>
                    </div>
                `;
                const nicknameForm = document.getElementById('nickname-form');
                const nicknameInput = document.getElementById('nickname-input');
                nicknameForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const nickname = nicknameInput.value.trim();
                    if (nickname) {
                        currentUser = nickname;
                        
                        // Setze Initialwerte für Leaderboard-Felder
                        await setDoc(doc(db, `/artifacts/${appId}/public/data/leaderboard`, userId), { 
                            nickname: currentUser,
                            minutes: 0,
                            weightedMinutes: 0,
                            lastUpdated: new Date()
                        }, { merge: true });
                        
                        await loadAllData();
                        renderApp();
                    } else {
                        showDynamicModal("Ungültiger Spitzname", "Bitte geben Sie einen gültigen Spitznamen ein.", [{ id: 'modal-close-btn', text: 'OK', class: 'w-full bg-primary text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition-colors', onClick: () => modal.classList.add('hidden') }]);
                    }
                });
            }

            /** Rendert die Haupt-App. */
            function renderApp() {
                // Das Challenge-Enddatum des Benutzers holen
                const { startDate, endDate } = getChallengePeriod(entries); 

                appContainer.innerHTML = `
                    <div class="flex-grow w-full max-w-4xl mx-auto space-y-6">
                        <!-- Navigationsleiste -->
                        <nav class="bg-slate-700 rounded-xl p-2 flex flex-col sm:flex-row justify-start gap-2">
                            <button data-section="dashboard" class="nav-button text-sm sm:text-base bg-primary text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">Dashboard</button>
                            <button data-section="add-entry" class="nav-button text-sm sm:text-base bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-500 transition-colors">Sport tracken</button>
                            <button data-section="add-sport" class="nav-button text-sm sm:text-base bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-500 transition-colors">Neue Sportart erstellen</button>
                            <button data-section="about-app" class="nav-button text-sm sm:text-base bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-500 transition-colors">Über die App</button>
                        </nav>
                        <!-- Abschnitt für das Dashboard -->
                        <div id="dashboard-section" class="space-y-6">
                            
                            <!-- Teilnehmer Abschnitt (Rangliste) -->
                            <div class="card bg-slate-700 p-6 rounded-xl">
                                <h2 id="dashboard-title" class="text-xl sm:text-2xl font-bold text-white mb-4">Rangliste</h2>
                                <div id="leaderboard" class="space-y-4">
                                    <!-- Die Rangliste wird hier geladen -->
                                </div>
                            </div>
                            
                            <!-- Fortschritt Abschnitt (8.000 Min) -->
                            <div class="card bg-slate-700 p-6 rounded-xl">
                                <h2 class="text-xl sm:text-2xl font-bold text-primary mb-4">Dein Basis Ziel (WHO gesund aktiv)</h2>
                                <div id="progress-8000-content"></div> 
                            </div>
                            
                            <!-- Coach für 8k Ziel -->
                            <div id="coach-active-container"></div>
                            
                            <!-- Aktivität / Graph Abschnitt (COLLAPSIBLE) -->
                            <div class="card bg-slate-700 p-6 rounded-xl">
                                <button data-target="activity" class="collapsible-btn w-full flex justify-between items-center text-lg font-bold text-white">
                                    Aktivität (Ungewichtete Minuten) 
                                    <span class="toggle-icon text-primary transform transition-transform duration-300">▼</span>
                                </button>
                                <div id="collapsible-activity" class="collapsible-content border-t border-slate-600 mt-3" data-rendered="false">
                                    <div class="pt-3">
                                        <p class="text-slate-400 text-center">Wird beim Ausklappen geladen...</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Minuten pro Sportart Auswertung (COLLAPSIBLE) -->
                            <div class="card bg-slate-700 p-6 rounded-xl">
                                <button data-target="sport-summary" class="collapsible-btn w-full flex justify-between items-center text-lg font-bold text-white">
                                    Minuten pro Sportart 
                                    <span class="toggle-icon text-primary transform transition-transform duration-300">▼</span>
                                </button>
                                <div id="collapsible-sport-summary" class="collapsible-content border-t border-slate-600 mt-3" data-rendered="false">
                                    <div id="sport-summary-list" class="space-y-2 pt-3">
                                        <p class="text-slate-400 text-center">Wird beim Ausklappen geladen...</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Letzte Aktivitäten Abschnitt (COLLAPSIBLE) -->
                            <div class="card bg-slate-700 p-6 rounded-xl">
                                <button data-target="recent-activities" class="collapsible-btn w-full flex justify-between items-center text-lg font-bold text-white">
                                    Letzte Aktivitäten 
                                    <span class="toggle-icon text-primary transform transition-transform duration-300">▼</span>
                                </button>
                                <div id="collapsible-recent-activities" class="collapsible-content border-t border-slate-600 mt-3" data-rendered="false">
                                    <div id="recent-activities" class="space-y-4 pt-3">
                                        <p class="text-slate-400 text-center">Wird beim Ausklappen geladen...</p>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Fortschritt Abschnitt (15.000 Min WHO) inkl. Coach (COLLAPSIBLE SECTION) -->
                            <div class="card bg-slate-700 p-6 rounded-xl border-2 border-slate-600">
                                <button data-target="stretch-goal" class="collapsible-btn w-full flex justify-between items-center text-xl sm:text-2xl font-bold text-accent">
                                    ⭐ Dein Stretch Goal (WHO fit & stark) 
                                    <span class="toggle-icon text-primary transform transition-transform duration-300">▼</span>
                                </button>
                                <div id="collapsible-stretch-goal" class="collapsible-content border-t border-slate-600 mt-3" data-rendered="false">
                                    <div class="pt-3">
                                        <p class="text-slate-400 text-center">Wird beim Ausklappen geladen...</p>
                                    </div>
                                </div>
                            </div>
                            
                        </div>
                        <!-- Abschnitt zum Eintragen von Sport -->
                        <div id="add-entry-section" class="hidden">
                            <div class="card bg-slate-700 p-6 rounded-xl">
                                <h2 class="text-xl sm:text-2xl font-bold text-white mb-4">Sport hinzufügen</h2>
                                <form id="add-entry-form" class="space-y-4">
                                    <div>
                                        <label for="sport-select" class="block text-slate-300 font-semibold mb-1">Sportart</label>
                                        <select id="sport-select" class="w-full p-3 rounded-lg bg-slate-800 text-white border border-slate-600 focus:outline-none focus:ring-2 focus:ring-primary">
                                            <!-- Sportarten werden hier dynamisch geladen -->
                                        </select>
                                    </div>
                                    <div>
                                        <label for="date-input" class="block text-slate-300 font-semibold mb-1">Datum</label>
                                        <!-- Korrektur für mobile Darstellung -->
                                        <input type="date" id="date-input" class="w-full p-3 rounded-lg bg-slate-800 text-white border border-slate-600 focus:outline-none focus:ring-2 focus:ring-primary appearance-none">
                                    </div>
                                    <div>
                                        <label for="minutes-input" class="block text-slate-300 font-semibold mb-1">Minuten</label>
                                        <input type="number" id="minutes-input" value="0" min="0" class="w-full p-3 rounded-lg bg-slate-800 text-white text-center text-lg font-bold border border-slate-600 focus:outline-none focus:ring-2 focus:ring-primary">
                                        <div class="mt-2 grid grid-cols-4 gap-2">
                                            <button type="button" data-minutes="5" class="minutes-btn text-sm w-full bg-slate-600 text-white font-semibold py-2 rounded-lg hover:bg-slate-500 transition-colors">+5</button>
                                            <button type="button" data-minutes="10" class="minutes-btn text-sm w-full bg-slate-600 text-white font-semibold py-2 rounded-lg hover:bg-slate-500 transition-colors">+10</button>
                                            <button type="button" data-minutes="15" class="minutes-btn text-sm w-full bg-slate-600 text-white font-semibold py-2 rounded-lg hover:bg-slate-500 transition-colors">+15</button>
                                            <button type="button" data-minutes="30" class="minutes-btn text-sm w-full bg-slate-600 text-white font-semibold py-2 rounded-lg hover:bg-slate-500 transition-colors">+30</button>
                                            <button type="button" data-minutes="45" class="minutes-btn text-sm w-full bg-slate-600 text-white font-semibold py-2 rounded-lg hover:bg-slate-500 transition-colors">+45</button>
                                            <button type="button" data-minutes="60" class="minutes-btn text-sm w-full bg-slate-600 text-white font-semibold py-2 rounded-lg hover:bg-slate-500 transition-colors">+60</button>
                                            <button type="button" id="clear-minutes-btn" class="w-full col-span-2 bg-secondary text-white font-semibold py-2 rounded-lg hover:bg-red-600 transition-colors">Löschen</button>
                                        </div>
                                    </div>
                                    <button type="submit" class="w-full bg-primary text-white font-semibold py-3 rounded-lg hover:bg-blue-700 transition-colors">Eintrag hinzufügen</button>
                                </form>
                            </div>
                        </div>
                        <!-- Abschnitt zum Hinzufügen eigener Sportarten -->
                        <div id="add-sport-section" class="hidden">
                            <div class="card bg-slate-700 p-6 rounded-xl">
                                <h2 class="text-xl sm:text-2xl font-bold text-white mb-4">Eigene Sportart hinzufügen</h2>
                                <form id="add-sport-form" class="space-y-4">
                                    <div>
                                        <label for="new-sport-name" class="block text-slate-300 font-semibold mb-1">Name der Sportart</label>
                                        <input type="text" id="new-sport-name" placeholder="z.b. Boxen" class="w-full p-3 rounded-lg bg-slate-800 text-white border border-slate-600 focus:outline-none focus:ring-2 focus:ring-primary">
                                    </div>
                                    <div>
                                        <label for="new-sport-weight" class="block text-slate-300 font-semibold mb-1">Gewichtung (z.b. 1.5)</label>
                                        <input type="number" step="0.1" id="new-sport-weight" placeholder="z.b. 1.5" class="w-full p-3 rounded-lg bg-slate-800 text-white border border-slate-600 focus:outline-none focus:ring-2 focus:ring-primary">
                                    </div>
                                    <button type="submit" class="w-full bg-primary text-white font-semibold py-3 rounded-lg hover:bg-blue-700 transition-colors">Sportart hinzufügen</button>
                                </form>
                                <div class="mt-8">
                                    <h3 class="text-lg font-bold text-white mb-2">Aktuelle Sportarten und Gewichtungen</h3>
                                    <div id="sport-weight-list" class="space-y-2">
                                        <!-- Die Liste wird hier geladen -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- NEUE Sektion für "Über die App" / Profil -->
                        <div id="about-app-section" class="hidden">
                            <div class="card bg-slate-700 p-6 rounded-xl border border-slate-600">
                                
                                <!-- Über die App Sektion -->
                                <section class="mb-8">
                                    <h2 class="text-2xl font-bold text-primary mb-4 flex justify-between items-center">
                                        Über die App
                                    </h2>
                                    <div class="space-y-4 text-slate-300">
                                        <p>Hey! Diese App ist dein persönlicher Motivator für die Sport Challenge 2025/26. Dein Ziel: Halte deinen sportlichen Fortschritt fest, messe dich mit Freunden und erreiche die Gesundheitsziele der WHO.</p>

                                        <h3 class="text-xl font-bold text-white mt-4 mb-2">Deine Ziele & die WHO-Empfehlungen</h3>
                                        <ul class="list-disc list-inside space-y-1 sm:ml-0">
                                            <li><span class="font-semibold">WHO gesund aktiv:</span> Das Basis-Ziel. Es entspricht der minimal empfohlenen aeroben Aktivität pro Woche, auf ein Jahr hochgerechnet (8.000 Min).</li>
                                            <li><span class="font-semibold">WHO fit & stark:</span> Das Herausforderungs-Ziel für maximale Gesundheitswirkung (15.000 Min).</li>
                                            <li><span class="font-semibold">Krafttraining:</span> Die WHO empfiehlt mindestens zweimal pro Woche muskelkräftigende Übungen. Der Counter im Dashboard hilft dir, diesen wöchentlichen Rhythmus zu verfolgen.</li>
                                        </ul>
                                        
                                        <h3 class="text-xl font-bold text-white mt-4 mb-2">Warum die Gewichtungen (x-Faktor)?</h3>
                                        <p>Nicht jede Minute ist gleich! Die Gewichtungsfaktoren (z.B. Laufen x1.5) spiegeln die geschätzte Intensität wider. Aktivitäten mit höherer Intensität (z.B. Schwimmen oder HIIT) lassen deine gewichteten Minuten schneller wachsen:</p>
                                        <ul class="list-disc list-inside space-y-1 sm:ml-0">
                                            <li>Faktoren > 1.0: Höhere Intensität (z.B. Laufen, Schwimmen).</li>
                                            <li>Faktoren < 1.0: Geringere Intensität (z.b. Yoga, Wandern).</li>
                                        </ul>
                                        <p class="text-sm text-slate-400 mt-2">Deine Ranglistenposition zählt immer nur die ungewichteten, realen Minuten, um den Vergleich fair zu halten. Die Gewichtung ist für deine persönliche Motivation da.</p>
                                    </div>
                                </section>
                                    
                                <!-- Dein Profil Sektion -->
                                <section class="p-6 rounded-xl bg-slate-800 border border-primary">
                                    <h2 class="text-xl sm:text-2xl font-bold text-white mb-3">Dein Profil</h2>
                                    <h3 class="text-xl font-bold text-white mb-2 sm:mb-0">Spitzname: <span class="text-primary" id="profile-nickname-section"></span></h3>
                                    
                                    <!-- ANZEIGE DES INDIVIDUELLEN STARTDATUMS -->
                                    <p class="text-sm text-slate-400 mt-2">
                                        Challenge Start: <span class="text-white font-semibold" id="challenge-start-date">${endDate.toLocaleDateString('de-DE')}</span>
                                        (Ende: <span class="text-white font-semibold">${endDate.toLocaleDateString('de-DE')}</span>)
                                    </p>

                                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mt-4">
                                        <p class="text-sm text-slate-400 mb-3 sm:mb-0">
                                            Deine volle ID (zum Synchronisieren): 
                                            <code id="profile-user-id-section" class="text-xs text-accent select-all font-mono"></code>
                                        </p>
                                        <button id="copy-user-id-btn-section" class="bg-primary text-white text-sm font-semibold py-2 px-3 rounded-lg hover:bg-blue-700 transition-colors flex items-center space-x-2">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">
                                                <path d="M7 3.75A2.75 2.75 0 019.75 1h5.5A2.75 2.75 0 0118 3.75v8.5A2.75 2.75 0 0115.25 15h-5.5A2.75 2.75 0 017 12.25v-8.5z" />
                                                <path fill-rule="evenodd" d="M11.375 16.5a1.25 1.25 0 01-1.25-1.25V5.25h1.5v10a.25.25 0 00.25.25h10.25a1.25 1.25 0 01-1.25 1.25h-9.5z" clip-rule="evenodd" />
                                            </svg>
                                            <span>ID kopieren</span>
                                        </button>
                                    </div>
                                    <p class="text-xs text-slate-500 mt-3">
                                        <strong>Synchronisation:</strong> Kopiere diese ID. Auf einem <strong>neuen Gerät</strong> kannst du dich dann mit dieser ID statt mit einem neuen Spitznamen anmelden, um deinen bestehenden Account und alle deine Daten nahtlos weiterzuführen.
                                    </p>
                                </section>
                            </div>
                        </div>
                    </div>
                `;
                const dateInput = document.getElementById('date-input');
                const today = new Date().toISOString().split('T')[0];
                if (dateInput) dateInput.value = today;

                // --- LOGIK FÜR PROFIL-SEKTION (INNERHALB DER APP) ---
                const profileNicknameEl = document.getElementById('profile-nickname-section');
                const profileUserIdEl = document.getElementById('profile-user-id-section');
                const copyIdBtn = document.getElementById('copy-user-id-btn-section');

                if (profileNicknameEl && profileUserIdEl && userId && currentUser) {
                    profileNicknameEl.textContent = currentUser;
                    profileUserIdEl.textContent = userId;
                    
                    if (copyIdBtn) {
                        copyIdBtn.addEventListener('click', () => {
                            copyToClipboard(userId, 'Volle ID wurde in die Zwischenablage kopiert. Nutze diese, um dich auf einem anderen Gerät anzumelden.');
                        });
                    }
                }
                // --- ENDE PROFIL-LOGIK ---

                setupEventListeners();
                // Beim Start wird das Dashboard mit den eigenen Einträgen gerendert
                const entriesToUse = (displayedUserId === userId) ? entries : (userEntriesCache[displayedUserId] || []);
                showSection('dashboard', entriesToUse);
            }

            /**
             * Zeigt einen bestimmten Abschnitt an und verbirgt die anderen.
             * @param {string} sectionId - Die ID des anzuzeigenden Abschnitts.
             */
            function showSection(sectionId) {
                document.querySelectorAll('.nav-button').forEach(btn => {
                    const isSelected = btn.dataset.section === sectionId;
                    btn.classList.toggle('bg-primary', isSelected);
                    btn.classList.toggle('hover:bg-blue-700', isSelected);
                    btn.classList.toggle('bg-slate-600', !isSelected);
                    btn.classList.toggle('hover:bg-slate-500', !isSelected);
                });

                document.getElementById('dashboard-section').classList.toggle('hidden', sectionId !== 'dashboard');
                document.getElementById('add-entry-section').classList.toggle('hidden', sectionId !== 'add-entry');
                document.getElementById('add-sport-section').classList.toggle('hidden', sectionId !== 'add-sport');
                document.getElementById('about-app-section').classList.toggle('hidden', sectionId !== 'about-app');

                // Ruft nur die relevanten Rendering-Funktionen auf
                if (sectionId === 'dashboard') {
                    // NEU: Gib die richtigen Einträge weiter (eigene oder gecachte)
                    const entriesToUse = (displayedUserId === userId) ? entries : (userEntriesCache[displayedUserId] || []);
                    renderDashboardContent(entriesToUse); 
                    renderSportSelect();
                } else if (sectionId === 'add-sport') {
                    renderSportSelect(); // Für das Dropdown im Hinzufügen-Formular
                    renderAddSportSectionContent(); // Rendert die Liste der Sportarten
                } else if (sectionId === 'add-entry') {
                    renderSportSelect(); // Für das Dropdown im Eintragsformular
                }
            }

            /** Aktualisiert die UI-Elemente, die sich im Dashboard befinden */
            // WICHTIGE ÄNDERUNG: Nimmt jetzt die zu verwendenden Einträge entgegen
            function renderDashboardContent(currentEntries) { 
                
                // Aktualisiere den Dashboard-Titel
                const titleEl = document.getElementById('dashboard-title');
                if (titleEl) {
                    titleEl.textContent = 'Rangliste'; // Immer "Rangliste" anzeigen
                }

                // LeaderboardParticipants ist jetzt ein stabiler, sortierter Array
                renderLeaderboard(leaderboardParticipants); 
                
                // Hauptelemente, die immer geladen werden:
                renderGoalProgress('8000', GOAL_MINUTES, currentEntries);
                renderCoachActiveGoal(currentEntries); 

                // Falls der Nutzer wechselt, müssen wir den Inhalt von bereits geöffneten Sektionen aktualisieren.
                if (document.querySelector('.collapsible-content-expanded')) {
                    document.querySelectorAll('.collapsible-content[data-rendered="true"]').forEach(contentEl => {
                        const targetId = contentEl.id.replace('collapsible-', '');
                        // Erzwinge Neurendern mit den neuen User-Daten, falls geöffnet
                        renderCollapsedContent(targetId, currentEntries);
                    });
                }
            }

            /** Rendert den Inhalt einer kollabierbaren Sektion (wird von toggleContentAndRender aufgerufen) */
            function renderCollapsedContent(targetId, entriesToUse) {
                const contentEl = document.getElementById(`collapsible-${targetId}`);
                const contentWrapper = contentEl.querySelector('div'); // Der div-Platzhalter innerhalb des contentEl

                if (targetId === 'activity') {
                    contentWrapper.innerHTML = `
                        <div class="flex justify-center gap-2 mb-4" id="timeframe-buttons">
                            <button data-timeframe="week" class="timeframe-btn text-sm bg-primary text-white font-semibold py-1 px-3 rounded-full hover:bg-blue-700 transition-colors">Woche</button>
                            <button data-timeframe="month" class="timeframe-btn text-sm bg-slate-600 text-white font-semibold py-1 px-3 rounded-full hover:bg-slate-500 transition-colors">Monat</button>
                            <button data-timeframe="year" class="timeframe-btn text-sm bg-slate-600 text-white font-semibold py-1 px-3 rounded-full hover:bg-slate-500 transition-colors">Jahr</button>
                        </div>
                        <canvas id="weekly-chart" class="w-full h-48"></canvas>
                    `;
                    setupTimeframeListeners(entriesToUse);
                    renderWeeklyProgressGraph(entriesToUse); // Ruft Graph-Rendering auf
                } else if (targetId === 'sport-summary') {
                    // renderSportSummary rendert direkt in #sport-summary-list, welches sich im Wrapper befindet
                    contentWrapper.innerHTML = `<div id="sport-summary-list" class="space-y-2 pt-3"></div>`;
                    renderSportSummary(entriesToUse); 
                } else if (targetId === 'recent-activities') {
                    // renderRecentActivities rendert direkt in #recent-activities
                    contentWrapper.innerHTML = `<div id="recent-activities" class="space-y-4 pt-3"></div>`;
                    renderRecentActivities(entriesToUse); 
                    // Listener für Bearbeiten/Löschen der neuen Einträge neu setzen
                    setupRecentActivitiesListeners(); 
                } else if (targetId === 'stretch-goal') {
                    contentWrapper.innerHTML = `
                        <div id="progress-15000-content"></div> 
                        <div id="coach-fit-container"></div>
                    `;
                    renderGoalProgress('15000', WHO_GOAL_MINUTES, entriesToUse);
                    renderCoachFitGoal(entriesToUse);
                }
                
                // Nach dem Rendern die max-height neu setzen, falls die Sektion bereits offen war
                if (contentEl.classList.contains('collapsible-content-expanded')) {
                    // Wichtig: setze max-height nach dem Rendern, um die korrekte Scroll-Höhe zu erhalten (Coach Fix)
                    contentEl.style.maxHeight = contentEl.scrollHeight + "px";
                }
            }
            
            /** Aktualisiert die UI-Elemente, die sich in der Sporterstell-Sektion befinden */
            function renderAddSportSectionContent() {
                renderSportWeightList();
            }
            
            // =====================================
            // Collapsible Logic
            // =====================================

            function setupCollapsibleListeners() {
                document.querySelectorAll('.collapsible-btn').forEach(button => {
                    button.addEventListener('click', () => {
                        const targetId = button.dataset.target;
                        toggleContentAndRender(targetId);
                    });
                });
            }

            function toggleContentAndRender(targetId) {
                const contentEl = document.getElementById(`collapsible-${targetId}`);
                const button = document.querySelector(`.collapsible-btn[data-target="${targetId}"]`);
                const icon = button.querySelector('.toggle-icon');
                const isExpanded = contentEl.classList.contains('collapsible-content-expanded');
                const isRendered = contentEl.dataset.rendered === 'true';

                const entriesToUse = (displayedUserId === userId) ? entries : (userEntriesCache[displayedUserId] || []);

                if (isExpanded) {
                    // Collapse
                    contentEl.classList.remove('collapsible-content-expanded');
                    contentEl.style.maxHeight = '0';
                    icon.classList.remove('toggle-icon-rotated');
                    icon.textContent = '▼';
                } else {
                    // Expand & Lazy Render
                    if (!isRendered) {
                        // Ersten Lade-Placeholder entfernen und Inhalt rendern
                        renderCollapsedContent(targetId, entriesToUse);
                        contentEl.dataset.rendered = 'true';
                    } else {
                        // Inhalt aktualisieren, falls User gewechselt wurde oder Daten neu geladen wurden
                        renderCollapsedContent(targetId, entriesToUse);
                    }

                    // Expand Animation starten
                    contentEl.classList.add('collapsible-content-expanded');
                    // Wichtig: setze max-height nach dem Rendern, um die korrekte Scroll-Höhe zu erhalten
                    contentEl.style.maxHeight = contentEl.scrollHeight + "px"; 
                    icon.classList.add('toggle-icon-rotated');
                    icon.textContent = '▲';
                }
            }
            
            // =====================================
            // Leaderboard Interaktion
            // =====================================

            /** Stellt den Fortschritt für einen bestimmten Benutzer in der Ansicht dar */
            async function showUserProgress(uid) {
                // Nur wenn der User wechselt ODER wenn der aktuell angezeigte User neu geladen werden muss (z.B. nach Eintrag)
                if (uid === displayedUserId && userId === uid) return; 
                
                let entriesToDisplay = [];
                const participant = leaderboardParticipants.find(p => p.id === uid);
                const nickname = participant ? participant.nickname : formatUserId(uid);

                if (uid === userId) {
                    entriesToDisplay = entries; // Eigene Daten sind global gespeichert
                } else if (userEntriesCache[uid]) {
                    entriesToDisplay = userEntriesCache[uid]; // Daten aus Cache
                } else {
                    // Zeige Ladezustand
                    document.getElementById('dashboard-section').innerHTML = `
                        <div class="flex-grow w-full max-w-4xl mx-auto space-y-6">
                            <h2 class="text-2xl font-bold text-center text-white pt-10">Lade Daten für ${nickname}...</h2>
                            <p class="text-center text-slate-400 animate-pulse-slow">Einen Moment bitte...</p>
                        </div>
                    `;
                    
                    // Daten abrufen und in Cache speichern
                    pEntries = await getSportEntries(uid); 
                    userEntriesCache[uid] = pEntries; 
                    entriesToDisplay = pEntries;
                }
                
                displayedUserId = uid;
                renderApp(); // Ruft renderApp neu auf, um die Navigation und das Layout neu zu setzen
                // renderDashboardContent wird mit den neuen Einträgen aufgerufen und aktualisiert geöffnete Sektionen.
            }

            // =====================================
            // Personal Coach Modul
            // =====================================
            
            /** * Hilfsfunktion zur Berechnung des Soll-Fortschritts für die Minuten. 
              * @param {number} goalMinutes - Das gesamte Minuten-Ziel (8000 oder 15000).
              * @param {Date} startDate - Das Challenge Startdatum.
              * @param {Date} endDate - Das Challenge Enddatum.
              * @returns {{requiredProgressPercentage: number, requiredMinutes: number}}
              */
            function calculateRequiredProgress(goalMinutes, startDate, endDate) {
                const now = new Date();
                const totalDurationMs = endDate.getTime() - startDate.getTime();
                const elapsedTimeMs = now.getTime() - startDate.getTime();
                
                let requiredProgressPercentage = 0;
                let requiredMinutes = 0;

                if (totalDurationMs > 0 && elapsedTimeMs > 0) {
                    const clampedElapsedTimeMs = Math.min(elapsedTimeMs, totalDurationMs); 
                    requiredProgressPercentage = (clampedElapsedTimeMs / totalDurationMs) * 100;
                    requiredMinutes = (requiredProgressPercentage / 100) * goalMinutes;
                } else if (elapsedTimeMs <= 0) {
                     requiredProgressPercentage = 0; // Challenge hat noch nicht begonnen (nach Startdatum des Users)
                } else if (elapsedTimeMs >= totalDurationMs) {
                    requiredProgressPercentage = 100;
                    requiredMinutes = goalMinutes;
                }
                return { requiredProgressPercentage, requiredMinutes };
            }

            /** Berechnet den Fortschritt beim Krafttraining über den gesamten Zeitraum. */
            function calculateStrengthTrainingProgress(entries, startDate, endDate) {
                const now = new Date();
                const requiredWeeklyRate = 2; // WHO requirement
                const totalDurationMs = endDate.getTime() - startDate.getTime();
                
                // 1. Calculate Actual Strength Units achieved in the challenge window (unique days)
                const strengthUnitsAchieved = new Set();
                entries.forEach(entry => {
                    const entryDate = entry.timestamp.toDate ? entry.timestamp.toDate() : new Date(entry.timestamp);
                    // Ensure entry is within the effective challenge period and is a strength sport
                    if (STRENGTH_SPORTS.includes(entry.sport) && entryDate >= startDate && entryDate <= now) {
                        // Count unique days (date part only) as 1 unit
                        strengthUnitsAchieved.add(entryDate.toISOString().split('T')[0]);
                    }
                });

                const actualUnits = strengthUnitsAchieved.size;

                // 2. Calculate Required Strength Units (Soll)
                const elapsedMs = now.getTime() - startDate.getTime();
                
                let requiredUnits = 0;
                
                if (elapsedMs > 0 && totalDurationMs > 0) {
                    const elapsedDays = Math.min(elapsedMs / (1000 * 60 * 60 * 24), totalDurationMs / (1000 * 60 * 60 * 24));
                    
                    // Required strength units = (Elapsed Days / 7 days) * 2 units
                    requiredUnits = (elapsedDays / 7) * requiredWeeklyRate;
                } else if (elapsedMs >= totalDurationMs) {
                    // If challenge is over, goal is the total maximum days
                    requiredUnits = (totalDurationMs / (1000 * 60 * 60 * 24) / 7) * requiredWeeklyRate; 
                }
                
                return { actualUnits: actualUnits, requiredUnits: requiredUnits };
            }
            
            /**
             * Generiert den HTML-Inhalt für den Coach basierend auf einem spezifischen Fokus.
             * @param {'active' | 'fit'} focus - Welches Ziel fokussiert werden soll.
             * @param {Array<Object>} entries - Die Sporteinträge des Benutzers.
             */
            function generateCoachAdviceHtml(focus, entries) {
                const { startDate, endDate } = getChallengePeriod(entries); // Holen Sie den dynamischen Zeitraum

                const { requiredProgressPercentage: required8k } = calculateRequiredProgress(GOAL_MINUTES, startDate, endDate);
                const { requiredProgressPercentage: required15k } = calculateRequiredProgress(WHO_GOAL_MINUTES, startDate, endDate);
                
                const totalMinutes = entries.reduce((sum, entry) => sum + entry.minutes, 0);
                
                const progress8k = (totalMinutes / GOAL_MINUTES) * 100;
                const progress15k = (totalMinutes / WHO_GOAL_MINUTES) * 100;
                
                const minutesLag8k = required8k - progress8k;
                const minutesLag15k = required15k - progress15k;

                const { actualUnits, requiredUnits } = calculateStrengthTrainingProgress(entries, startDate, endDate);
                const strengthLag = requiredUnits - actualUnits;

                let adviceHeadline = "";
                let adviceTextHtml = "";
                
                const getTopSport = () => entries.length > 0 ? Object.keys(entries.reduce((acc, entry) => {
                    acc[entry.sport] = (acc[entry.sport] || 0) + entry.minutes;
                    return acc;
                }, {})).sort((a, b) => entries.filter(e => e.sport === b).length - entries.filter(e => e.sport === a).length)[0] || "Laufen" : "Laufen";


                if (focus === 'active') {
                    // --- Coach Active (Fokus: 8k Minuten) ---
                    if (entries.length === 0) {
                        adviceHeadline = "Legen Sie los!";
                        adviceTextHtml = `<p class="text-slate-300">Es wurden noch keine Einträge für diesen Benutzer gefunden. Tragen Sie jetzt Ihre erste Aktivität ein, um die Challenge zu starten!</p>`;
                    } else if (progress8k >= 100) {
                        adviceHeadline = "Ziel A erreicht! Du bist bereits fit.";
                        adviceTextHtml = `<p class="text-slate-300">Fantastisch! Du hast dein **Basis-Ziel von 8.000 Minuten** bereits überschritten. Jetzt geht es darum, die Konsistenz zu halten oder das Stretch Goal anzuvisieren.</p>`;
                    } else if (minutesLag8k > 5) {
                        adviceHeadline = "Aufholen nötig: WHO aktiv Ziel in Gefahr.";
                        adviceTextHtml = `<p class="text-slate-300">Dieser Benutzer ist im Rückstand! Der Plan läuft mit <span class="font-bold text-secondary">${minutesLag8k.toFixed(1)}%</span> Vorsprung davon. Der Fokus sollte auf Regelmäßigkeit liegen.</p>`;
                        adviceTextHtml += `<h3 class="text-lg font-bold text-primary mt-3">Mission:</h3>`;
                        adviceTextHtml += `<p class="text-white">Füge den nächsten <span class="font-bold">${getTopSport()}</span>-Einheiten <span class="font-bold">jeweils 15 Minuten</span> hinzu. Kleine Steigerungen bringen große Ergebnisse!</p>`;
                    } else {
                        adviceHeadline = "Im Zeitplan: WHO aktiv Ziel auf Kurs.";
                        adviceTextHtml = `<p class="text-slate-300">Perfekt! Dieser Benutzer ist aktuell im Zeitplan, um das 8.000-Minuten-Basis-Ziel zu erreichen. Halten Sie diesen Rhythmus bei, um das Fundament zu sichern.</p>`;
                    }

                } else if (focus === 'fit') {
                    // --- Coach Fit (Fokus: Krafttraining + 15k Minuten) ---
                     if (entries.length === 0) {
                        adviceHeadline = "Zieleingabe ausstehend.";
                        adviceTextHtml = `<p class="text-slate-300">Füge zuerst Aktivitäten hinzu, um Coach-Feedback zu erhalten.</p>`;
                    } else if (strengthLag > 10) {
                        adviceHeadline = "Dringend: Krafttraining nachholen!";
                        adviceTextHtml = `<p class="text-slate-300">Die Ausdauer ist super, aber das Krafttraining wird vernachlässigt. Der Benutzer liegt um <span class="font-bold text-secondary">${strengthLag.toFixed(1)} Einheiten</span> hinter dem Plan. Krafttraining ist essenziell für die Erreichung des 'fit & stark' Ziels.</p>`;
                        adviceTextHtml += `<h3 class="text-lg font-bold text-primary mt-3">Mission:</h3>`;
                        adviceTextHtml += `<p class="text-white">Starte diese Woche mit <span class="font-bold">zwei 15-minütigen</span> Yoga- oder Krafttrainingseinheiten (z.B. HIIT). Priorität: Kraft!</p>`;
                    } else if (progress15k >= 100) {
                        adviceHeadline = "Grandios! Der Benutzer ist 'fit & stark'.";
                        adviceTextHtml = `<p class="text-slate-300">Herzlichen Glückwunsch! Der Benutzer hat das anspruchsvolle 15.000-Minuten-Stretch Goal erreicht. Er ist offiziell 'fit & stark'. Jetzt nur noch die Konsistenz halten!</p>`;
                    } else if (minutesLag15k > 5) {
                        adviceHeadline = "Top-Ziel in Sicht: Intensität erhöhen.";
                        adviceTextHtml = `<p class="text-slate-300">Der Benutzer ist auf dem Weg, aber das 15.000-Minuten-Ziel läuft mit <span class="font-bold text-secondary">${minutesLag15k.toFixed(1)}%</span> Vorsprung davon. Es müssen mehr Minuten pro Woche gesammelt werden, um aufzuholen.</p>`;
                        adviceTextHtml += `<h3 class="text-lg font-bold text-primary mt-3">Mission:</h3>`;
                        adviceTextHtml += `<p class="text-white">Wähle eine Aktivität mit hohem Multiplikator (wie Schwimmen oder HIIT) und füge eine <span class="font-bold">zweite Session</span> pro Woche ein.</p>`;
                    } else {
                        adviceHeadline = "Voller Flow! Weiter so!";
                        adviceTextHtml = `<p class="text-slate-300">Der Benutzer hält den Rhythmus! Er ist gut aufgestellt, um sowohl die Krafttrainings-Einheiten zu absolvieren als auch das anspruchsvolle 15.000-Minuten-Ziel zu erreichen.</p>`;
                    }
                }
                
                // Final HTML structure for the coach container
                return `
                    <div class="card bg-slate-800 p-5 rounded-xl border border-slate-700 mt-4">
                        <div class="flex items-center space-x-3 pb-2 border-b border-slate-700 mb-3">
                            <h3 class="text-xl font-bold text-white">${adviceHeadline}</h3>
                            <span class="text-xs text-primary bg-slate-700 px-2 py-1 rounded-full font-semibold ml-auto">Coach</span>
                        </div>
                        <div class="space-y-3">
                            ${adviceTextHtml}
                        </div>
                    </div>
                `;
            }

            /** Rendert den Coach für das WHO aktiv Ziel (8k). */
            function renderCoachActiveGoal(myEntries) {
                const container = document.getElementById('coach-active-container');
                if (!container) return; 
                // Coach wird immer für die übergebenen Einträge gerendert
                container.innerHTML = generateCoachAdviceHtml('active', myEntries);
            }

            /** Rendert den Coach für das WHO fit & stark Ziel (15k + Kraft). */
            function renderCoachFitGoal(myEntries) {
                const container = document.getElementById('coach-fit-container');
                if (!container) return; 
                // Coach wird immer für die übergebenen Einträge gerendert
                container.innerHTML = generateCoachAdviceHtml('fit', myEntries);
            }
            // =====================================
            // Ende Personal Coach Modul
            // =====================================
            
            /** Kürzt die Firebase UID für die Anzeige. */
            function formatUserId(uid) {
                if (!uid) return 'N/A';
                return uid.substring(0, 8); // Zeigt die ersten 8 Zeichen der UID
            }

            /** Rendert die Sportarten-Dropdown-Liste neu */
            function renderSportSelect() {
                const sportSelect = document.getElementById('sport-select');
                // Hinzugefügt für das Bearbeitungs-Dropdown, das nach dem DOM-Update möglicherweise noch existiert
                const editSportSelect = document.getElementById('edit-sport-select'); 

                const optionsHtml = Object.keys(allSports).map(sport => 
                    `<option value="${sport}">${sport} (x${allSports[sport]})</option>`
                ).join('');
                
                if (sportSelect) sportSelect.innerHTML = optionsHtml;
                // Aktualisiere auch das Bearbeitungs-Dropdown, falls es im DOM ist
                if (editSportSelect) {
                    const currentEntry = entries.find(e => e.id === editingDocId);
                    if (currentEntry) {
                        editSportSelect.innerHTML = Object.keys(allSports).map(sport => 
                            `<option value="${sport}" ${sport === currentEntry.sport ? 'selected' : ''}>${sport} (x${allSports[sport]})</option>`
                        ).join('');
                    } else {
                        editSportSelect.innerHTML = optionsHtml;
                    }
                }
            }
            
            /** Rendert die Liste der Sportarten und ihrer Gewichtungen. */
            function renderSportWeightList() {
                const sportWeightListEl = document.getElementById('sport-weight-list');
                if (!sportWeightListEl) return;
                
                sportWeightListEl.innerHTML = Object.entries(allSports).map(([sport, weight]) => {
                    // Prüfe, ob es sich um eine benutzerdefinierte Sportart handelt (Nicht in den Standard-Weights)
                    const isCustom = !SPORT_WEIGHTS.hasOwnProperty(sport); 
                    
                    const deleteButton = isCustom ? `
                        <button data-sport-name="${sport}" data-action="delete-sport" class="text-secondary hover:text-red-400 transition-colors text-sm font-semibold p-1 rounded-lg">
                            Löschen
                        </button>
                    ` : `<span class="text-slate-500 text-sm">Standard</span>`;

                    return `
                        <div class="flex justify-between items-center p-3 bg-slate-800 rounded-lg border border-slate-600 ${isCustom ? 'border-primary' : ''}">
                            <span class="text-white font-semibold">${sport}</span>
                            <div class="flex items-center space-x-3">
                                <span class="text-primary font-bold">x${weight}</span>
                                ${deleteButton}
                            </div>
                        </div>
                    `;
                }).join('');

                 // Event-Delegation für den Lösch-Button
                sportWeightListEl.querySelectorAll('[data-action="delete-sport"]').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const sportName = e.target.dataset.sportName;
                        handleDeleteSport(sportName);
                    });
                });
            }

            /** Rendert einen Fortschrittsbalken. */
            function renderGoalProgress(idSuffix, goalMinutes, myEntries) {
                const containerEl = document.getElementById(`progress-${idSuffix}-content`);
                // WICHTIG: Prüfen, ob der Container existiert
                if (!containerEl || !myEntries) return; 

                // Stelle sicher, dass der Coach nur die eigenen Daten sieht
                const isPersonalView = displayedUserId === userId;

                const isWeightedGoal = idSuffix === '8000'; 
                const currentView = isWeightedGoal && isPersonalView ? myProgressView : 'minutes';

                const { startDate, endDate } = getChallengePeriod(myEntries); // Holen Sie den dynamischen Zeitraum
                
                const { requiredProgressPercentage, requiredMinutes } = calculateRequiredProgress(goalMinutes, startDate, endDate);
                
                // --- BERECHNUNG: Ist-Fortschritt ---
                const totalMinutes = myEntries.reduce((sum, entry) => sum + entry.minutes, 0);
                const totalWeightedMinutes = myEntries.reduce((sum, entry) => {
                    const weight = allSports[entry.sport] || 1.0;
                    return sum + (entry.minutes * weight);
                }, 0);

                let displayValue = (currentView === 'minutes') ? totalMinutes : totalWeightedMinutes;
                let progress = (displayValue / goalMinutes) * 100;
                let isGoalReached = progress >= 100;
                
                // *** SKALIERUNG FÜR PROPORTIONALITÄT (IMMERS 100% BREITE) ***
                const relativeWidth = 100; 
                
                // *** SICHTBARKEITS-FIX (mindestens 2% Breite, wenn Fortschritt > 0) ***
                let actualWidth = Math.min(100, progress);
                if (progress > 0 && progress < 2) {
                    actualWidth = 2; 
                }

                // --- HTML-STRUKTUR & METRIKEN ---
                let metricBoxes = `
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-4 text-center">
                        <div class="p-3 rounded-lg bg-slate-800 border border-slate-600">
                            <div class="text-xs text-slate-400">Erreicht (${progress.toFixed(1)}%)</div> 
                            <div class="text-xl font-bold ${isGoalReached ? 'text-primary' : 'text-white'}">${displayValue.toFixed(currentView === 'weighted' ? 1 : 0)} Min</div>
                        </div>
                        <div class="p-3 rounded-lg bg-slate-800 border border-slate-600">
                            <div class="text-xs text-slate-400">Soll (${requiredProgressPercentage.toFixed(1)}%)</div>
                            <div class="text-xl font-bold text-white">${requiredMinutes.toFixed(0)} Min</div>
                        </div>
                        <div class="p-3 rounded-lg bg-slate-800 border border-slate-600">
                            <div class="text-xs text-slate-400">Status</div>
                            <div class="text-xl font-bold ${isGoalReached ? 'text-accent' : (progress >= requiredProgressPercentage ? 'text-primary' : 'text-secondary')}">
                                ${isGoalReached ? 'Ziel erreicht!' : (progress >= requiredProgressPercentage ? 'Im Zeitplan' : 'Aufholen nötig')}
                            </div>
                        </div>
                    </div>
                `;
                
                // Umschalt-Button nur für das 8000er Ziel und nur im eigenen Dashboard
                const toggleButton = (isWeightedGoal && isPersonalView) ? `
                    <div class="flex justify-center mb-4 items-center space-x-3">
                        <button id="toggle-progress-btn" data-goal-id="${idSuffix}" class="text-sm text-white py-1 px-3 rounded-full bg-primary hover:bg-blue-700 transition-colors">
                            Ansicht: ${currentView === 'minutes' ? 'Zu Gewichtete Min. wechseln' : 'Zu Ungewichtete Min. wechseln'}
                        </button>
                    </div>
                ` : `<div class="mb-4"></div>`; // Platzhalter für Konsistenz

                // --- KRAFTTRAINING COUNTER (NUR BEI 15000er ZIEL und nur in eigener Ansicht) ---
                let strengthCounter = '';
                // HINWEIS: Der Krafttraining-Counter wird nur für den aktuell eingeloggten Benutzer angezeigt,
                // da die WHO-Empfehlung ein individuelles Ziel ist.
                if (idSuffix === '15000' && isPersonalView) { 
                    const { actualUnits, requiredUnits } = calculateStrengthTrainingProgress(myEntries, startDate, endDate); 
                    const isGoalMet = actualUnits >= requiredUnits;
                    const strengthTooltipContent = `Eingerechnete Sportarten: ${STRENGTH_SPORTS.join(', ')}`;
                    
                    strengthCounter = `
                        <div class="mt-6 p-4 rounded-xl bg-slate-800 border border-slate-600">
                            <!-- NEUE STRUKTUR FÜR MOBILE OPTIMIERUNG -->
                            <div class="w-full space-y-2">
                                <!-- Zeile 1: Überschrift und Info-Icon -->
                                <div class="flex justify-between items-center">
                                    <div class="relative tooltip-container">
                                        <h3 class="text-lg font-bold text-white flex items-center">
                                            Krafttraining
                                            <span class="ml-2 text-primary cursor-pointer text-sm">
                                                [i]
                                                <span class="tooltip-content text-xs">${strengthTooltipContent}</span>
                                            </span>
                                        </h3>
                                    </div>
                                </div>

                                <!-- Zeile 2: Sollwert und Status (linksbündig) -->
                                <div class="flex justify-between items-center">
                                    <span class="text-sm text-slate-400">Soll: 2x/Woche</span>
                                    <div class="px-3 py-1 rounded-full text-white font-semibold ${isGoalMet ? 'bg-accent' : 'bg-secondary'} text-sm">
                                        ${isGoalMet ? 'Im Zeitplan!' : 'Aufholen nötig'}
                                    </div>
                                </div>
                                
                                <!-- Zeile 3: Aktuelle Leistung (groß und sichtbar) -->
                                <div class="pt-2">
                                    <span class="text-white text-xl font-extrabold">
                                        ${actualUnits.toFixed(0)} / ${requiredUnits.toFixed(1)} Einheiten erreicht
                                    </span>
                                </div>
                            </div>
                        </div>
                    `;
                }


                // --- GESAMTAUSGABE ---
                containerEl.innerHTML = `
                    ${metricBoxes}
                    ${toggleButton}
                    
                    <div style="max-width: ${relativeWidth}%;" class="w-full">
                        <div class="relative h-6 bg-slate-800 rounded-full mb-2 shadow-inner overflow-hidden">
                            <div id="progress-bar-${idSuffix}" class="h-full ${isGoalReached ? 'bg-primary' : 'bg-accent'} progress-bar-fill rounded-full" style="width: ${actualWidth}%;"></div>
                            <div id="target-marker-${idSuffix}" class="absolute top-0 bottom-0 target-marker" title="Soll-Fortschritt" style="left: ${requiredProgressPercentage}%; transform: translateX(-50%);"></div>
                        </div>
                    </div>
                    
                    <p class="text-left text-sm font-semibold text-slate-400 mt-0">
                        Ziel: ${goalMinutes.toLocaleString('de-DE')} Minuten.
                    </p>

                    ${strengthCounter}
                `;
                
                // Event Listener für den Toggle-Button muss neu angehängt werden
                if (isWeightedGoal && isPersonalView) {
                    document.getElementById('toggle-progress-btn')?.addEventListener('click', () => {
                        myProgressView = myProgressView === 'minutes' ? 'weighted' : 'minutes';
                        renderDashboardContent(myEntries); // Aktualisiere nur den Dashboard-Inhalt
                    });
                }
            }


            function renderWeeklyProgressGraph(myEntries) {
                const canvas = document.getElementById('weekly-chart');
                if (!canvas || !myEntries) return;
                // Wichtig: canvas muss sichtbar sein, bevor Breite/Höhe gelesen wird!

                const containerWidth = canvas.parentElement.clientWidth;
                canvas.width = containerWidth;
                canvas.height = 192;

                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                let dataPoints = [];
                let labels = [];

                const now = new Date();
                const getEntryDate = (entry) => entry.timestamp.toDate ? entry.timestamp.toDate() : new Date(entry.timestamp);

                if (chartTimeframe === 'week') {
                    const dailyMinutes = new Array(7).fill(0);
                    const oneWeekAgo = now.getTime() - 7 * 24 * 60 * 60 * 1000;
                    myEntries.filter(entry => getEntryDate(entry).getTime() > oneWeekAgo)
                        .forEach(entry => {
                            const entryDate = getEntryDate(entry);
                            const diffDays = Math.floor((now.getTime() - entryDate.getTime()) / (1000 * 60 * 60 * 24));
                            if (diffDays >= 0 && diffDays < 7) dailyMinutes[6 - diffDays] += entry.minutes;
                        });
                    dataPoints = dailyMinutes;
                    for (let i = 6; i >= 0; i--) {
                        const date = new Date(now);
                        date.setDate(now.getDate() - i);
                        labels.push(date.toLocaleDateString('de-DE', { weekday: 'short' }));
                    }
                } else if (chartTimeframe === 'month') {
                    const weeklyMinutes = new Array(4).fill(0);
                    const oneMonthAgo = now.getTime() - 30 * 24 * 60 * 60 * 1000;
                    myEntries.filter(entry => getEntryDate(entry).getTime() > oneMonthAgo)
                        .forEach(entry => {
                            const entryDate = getEntryDate(entry);
                            const diffDays = Math.floor((now.getTime() - entryDate.getTime()) / (1000 * 60 * 60 * 24));
                            const weekIndex = Math.floor(diffDays / 7);
                            if (weekIndex >= 0 && weekIndex < 4) weeklyMinutes[3 - weekIndex] += entry.minutes;
                        });
                    dataPoints = weeklyMinutes;
                    labels = ['Woche 1', 'Woche 2', 'Woche 3', 'Woche 4'];
                } else if (chartTimeframe === 'year') {
                    const monthlyMinutes = new Array(12).fill(0);
                    const oneYearAgo = now.getTime() - 365 * 24 * 60 * 60 * 1000;
                    myEntries.filter(entry => getEntryDate(entry).getTime() > oneYearAgo)
                        .forEach(entry => {
                            const entryDate = getEntryDate(entry);
                            const diffMonths = (now.getFullYear() - entryDate.getFullYear()) * 12 + (now.getMonth() - entryDate.getMonth());
                            if (diffMonths >= 0 && diffMonths < 12) monthlyMinutes[11 - diffMonths] += entry.minutes;
                        });
                    dataPoints = monthlyMinutes;
                    for (let i = 11; i >= 0; i--) {
                        const monthDate = new Date(now.getFullYear(), now.getMonth() - i, 1);
                        labels.push(monthDate.toLocaleDateString('de-DE', { month: 'short' }));
                    }
                }
                
                const maxMinutes = Math.max(...dataPoints, 1);
                const padding = 30;
                const chartHeight = canvas.height - 2 * padding;
                const chartWidth = canvas.width - 2 * padding;
                const pointSpacing = chartWidth / (dataPoints.length > 1 ? dataPoints.length - 1 : 1);

                ctx.beginPath();
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 3;
                const points = dataPoints.map((value, index) => ({
                    x: padding + index * pointSpacing,
                    y: padding + chartHeight - (value / maxMinutes) * chartHeight
                }));
                if (points.length > 0) {
                    ctx.moveTo(points[0].x, points[0].y);
                    points.forEach(point => ctx.lineTo(point.x, point.y));
                }
                ctx.stroke();
                
                ctx.textAlign = 'right';
                ctx.fillStyle = '#94a3b8';
                ctx.font = '10px Inter';
                const yLabels = [0, Math.floor(maxMinutes / 2), maxMinutes];
                yLabels.forEach(label => {
                    const y = padding + chartHeight - (label / maxMinutes) * chartHeight;
                    ctx.fillText(label, padding - 5, y + 4);
                });
                
                points.forEach(point => {
                    ctx.beginPath();
                    ctx.fillStyle = '#22c55e';
                    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.fillStyle = '#f3f4f6';
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                labels.forEach((label, index) => {
                    const x = padding + index * pointSpacing;
                    ctx.fillStyle = '#94a3b8';
                    ctx.fillText(label, x, canvas.height - 5);
                    ctx.fillStyle = '#f3f4f6';
                    ctx.fillText(dataPoints[index], x, points[index].y - 10);
                });
            }

            /**
             * Rendert die Rangliste als übersichtliche, responsive Liste.
             * @param {Array<Object>} participants - Liste aller Leaderboard-Teilnehmer (jetzt vorsortiert und angereichert).
             */
            function renderLeaderboard(participants) {
                const leaderboardEl = document.getElementById('leaderboard');
                if (!leaderboardEl || !participants) return;

                // participants ist jetzt bereits ein stabiler, vorsortierter Array mit progressRatio!
                let sortedParticipants = participants; 
                
                leaderboardEl.innerHTML = `
                    <p class="text-sm text-slate-400 mb-3">Sortiert nach prozentualer Differenz zum individuellen Sollwert des 8.000-Minuten-Ziels. Klicke auf eine Zeile, um die Details des Benutzers einzusehen.</p>
                    
                    <!-- Kopfzeile der Tabelle (responsive Grid) -->
                    <div class="bg-slate-800 rounded-t-lg p-3 grid grid-cols-6 sm:grid-cols-12 text-xs font-semibold text-slate-400 border-b border-slate-600 sticky top-0 z-10 shadow-md">
                        <div class="col-span-1">Rang</div>
                        <div class="col-span-3 sm:col-span-4">Name</div>
                        <div class="col-span-2 sm:col-span-3 text-right">Minuten (Ungew.)</div>
                        <div class="col-span-2 sm:col-span-2 text-right hidden sm:block">Gew. Min.</div>
                        <div class="col-span-2 sm:col-span-2 text-right">Soll-Differenz</div>
                    </div>

                    <div class="space-y-1">
                        ${sortedParticipants.map((p, index) => {
                            const isActiveUser = p.id === displayedUserId;
                            const isCurrentUser = p.id === userId;
                            const isLeading = index === 0;

                            // Hervorhebung der Zeile
                            const rowClasses = isActiveUser 
                                ? 'bg-primary/30 border-primary shadow-lg' 
                                : isCurrentUser
                                        ? 'bg-slate-700/60 border-slate-500'
                                        : 'bg-slate-800/80 border-slate-700 hover:bg-slate-700';

                            const rankColor = isLeading ? 'text-accent' : isActiveUser ? 'text-primary' : 'text-slate-400';
                            const nicknameColor = isActiveUser ? 'text-white font-extrabold' : 'text-white font-semibold';
                            // Nutzt das bereits berechnete progressRatio
                            const ratioColor = p.progressRatio >= 0 ? 'text-accent' : 'text-secondary';
                            
                            return `
                                <div data-user-id="${p.id}" class="grid grid-cols-6 sm:grid-cols-12 items-center p-3 rounded-lg border cursor-pointer transition-colors duration-150 ${rowClasses}">
                                    
                                    <!-- 1. Rang -->
                                    <div class="col-span-1 text-lg font-bold ${rankColor}">${index + 1}.</div>
                                    
                                    <!-- 2. Name -->
                                    <div class="col-span-3 sm:col-span-4 flex items-center space-x-2 ${nicknameColor} text-sm sm:text-base truncate">
                                        <span>${p.nickname}</span>
                                        ${isCurrentUser ? '<span class="text-xs text-primary bg-slate-700 px-2 py-0.5 rounded-full font-semibold hidden sm:inline-block">(Du)</span>' : ''}
                                        ${isLeading ? '<span class="text-lg ml-1">👑</span>' : ''}
                                    </div>
                                    
                                    <!-- 3. Minuten (Ungewichtet) -->
                                    <div class="col-span-2 sm:col-span-3 text-right font-extrabold text-sm sm:text-base text-white">
                                        ${p.minutes.toFixed(0)}
                                    </div>
                                    
                                    <!-- 4. Gewichtete Minuten (Hidden on mobile) -->
                                    <div class="col-span-2 sm:col-span-2 text-right font-bold text-sm sm:text-base text-white hidden sm:block">
                                        ${p.weightedMinutes.toFixed(1)}
                                    </div>

                                    <!-- 5. Soll-Differenz (Prozent) -->
                                    <div class="col-span-2 sm:col-span-2 text-right font-extrabold text-sm sm:text-base ${ratioColor}">
                                        ${p.progressRatio >= 0 ? '+' : ''}${p.progressRatio.toFixed(1)}%
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            function renderSportSummary(myEntries) {
                const summaryEl = document.getElementById('sport-summary-list');
                if (!summaryEl || !myEntries) return;

                const sportMinutes = {};
                myEntries.forEach(entry => {
                    const sportName = entry.sport;
                    if (!sportMinutes[sportName]) sportMinutes[sportName] = 0;
                    sportMinutes[sportName] += entry.minutes;
                });
                const sortedSports = Object.keys(sportMinutes).sort((a, b) => sportMinutes[b] - sportMinutes[a]);

                summaryEl.innerHTML = sortedSports.map(sport => `
                    <div class="flex justify-between items-center p-3 bg-slate-800 rounded-lg border border-slate-600">
                        <span class="text-white font-semibold">${sport}</span>
                        <span class="text-primary font-bold">${sportMinutes[sport]} Min</span>
                    </div>
                `).join('');
            }
            
            function setupRecentActivitiesListeners() {
                // Nur nötig, wenn die Sektion aktiv ist und eigene Daten anzeigt
                if (displayedUserId === userId) {
                    const recentActivitiesEl = document.getElementById('recent-activities');
                    if (recentActivitiesEl) {
                        recentActivitiesEl.querySelectorAll('button[data-action]').forEach(button => {
                            const action = button.dataset.action;
                            const docId = button.dataset.docId;

                            // Entferne alte Listener, bevor neue hinzugefügt werden
                            const newButton = button.cloneNode(true);
                            button.parentNode.replaceChild(newButton, button);
                            
                            if (action === 'delete') newButton.addEventListener('click', () => handleDeleteClick(docId));
                            else if (action === 'edit') newButton.addEventListener('click', () => handleEditClick(docId));
                            else if (action === 'save') newButton.addEventListener('click', () => handleSaveEdit(docId));
                            else if (action === 'cancel') newButton.addEventListener('click', handleCancelEdit);
                        });
                    }
                }
            }

            function renderRecentActivities(myEntries) {
                const recentActivitiesEl = document.getElementById('recent-activities');
                if (!recentActivitiesEl || !myEntries) return;
                
                const sortedActivities = myEntries.sort((a, b) => (b.timestamp.toDate ? b.timestamp.toDate() : new Date(b.timestamp)) - (a.timestamp.toDate ? a.timestamp.toDate() : new Date(b.timestamp)));
                
                // Begrenze auf die 5 neuesten Aktivitäten
                const limitedActivities = sortedActivities.slice(0, 5);

                if (limitedActivities.length === 0) {
                    recentActivitiesEl.innerHTML = '<p class="text-center text-slate-400 p-4">Keine Aktivitäten gefunden.</p>';
                    return;
                }
                // Zeige nur die Bearbeitungsbuttons, wenn es der eigene User ist
                const isPersonalView = displayedUserId === userId;

                recentActivitiesEl.innerHTML = limitedActivities.map(activity => {
                    const date = activity.timestamp.toDate ? activity.timestamp.toDate() : new Date(activity.timestamp);
                    // Zeige nur das Datum an
                    const dateString = date.toLocaleDateString('de-DE'); 
                    const isMyEntry = activity.userId === userId; // Prüfe, ob der Eintrag dem angemeldeten Benutzer gehört
                    const weight = allSports[activity.sport] || 1.0;
                    
                    if (isMyEntry && activity.id === editingDocId) {
                        // Bearbeitungsansicht
                        return `
                            <div class="flex flex-col p-4 bg-slate-800 rounded-lg border border-primary" data-doc-id="${activity.id}">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="text-white font-semibold">Eintrag von ${activity.nickname} bearbeiten</span>
                                    <div class="flex space-x-2">
                                        <button data-action="save" data-doc-id="${activity.id}" class="text-xs text-accent hover:text-green-400 transition-colors">Speichern</button>
                                        <button data-action="cancel" class="text-xs text-secondary hover:text-red-400 transition-colors">Abbrechen</button>
                                    </div>
                                </div>
                                <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
                                    <select id="edit-sport-select" class="w-full p-2 rounded-lg bg-slate-700 text-white text-sm">
                                        ${Object.keys(allSports).map(sport => 
                                            `<option value="${sport}" ${sport === activity.sport ? 'selected' : ''}>${sport} (x${allSports[sport]})</option>`
                                        ).join('')}
                                    </select>
                                    <input type="number" id="edit-minutes-input" class="w-full p-2 rounded-lg bg-slate-700 text-white text-sm" value="${activity.minutes}" min="1">
                                    <input type="date" id="edit-date-input" class="w-full p-2 rounded-lg bg-slate-700 text-white text-sm" value="${new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().split('T')[0]}">
                                </div>
                            </div>
                        `;
                    } else {
                        // Normale Ansicht
                        // Buttons nur anzeigen, wenn es der eigene Eintrag UND die eigene Ansicht ist
                        const actionButtons = (isMyEntry && isPersonalView) ? `
                            <div class="flex space-x-2">
                                <button data-action="edit" data-doc-id="${activity.id}" class="text-xs text-slate-400 hover:text-white transition-colors">Bearbeiten</button>
                                <button data-action="delete" data-doc-id="${activity.id}" class="text-xs text-secondary hover:text-red-400 transition-colors">Löschen</button>
                            </div>
                        ` : '';
                        return `
                            <div class="flex justify-between items-center p-3 bg-slate-800 rounded-lg border border-slate-600">
                                <div>
                                    <span class="text-white font-semibold">${activity.nickname}</span> hat <span class="text-primary font-bold">${activity.minutes} Min</span>
                                    <span class="text-accent font-semibold">${activity.sport}</span> (${weight}x) gemacht.
                                </div>
                                <div class="flex-shrink-0 text-right">
                                    <span class="text-xs text-slate-500 block mb-1">${dateString}</span>
                                    ${actionButtons}
                                </div>
                            </div>
                        `;
                    }
                }).join('');

                 // Füge eine Notiz hinzu, falls mehr Einträge vorhanden sind
                if (sortedActivities.length > 5) {
                    recentActivitiesEl.innerHTML += '<p class="text-center text-slate-500 mt-4 text-sm">... Es werden nur die neuesten 5 Aktivitäten angezeigt.</p>';
                }
                
                // Füge Listener für die neu gerenderten Buttons hinzu
                if (isPersonalView) {
                    setupRecentActivitiesListeners();
                }
            }
            
            /** Löscht eine benutzerdefinierte Sportart. */
            async function handleDeleteSport(sportName) {
                // Nur benutzerdefinierte Sportarten können gelöscht werden (Standard ist im SPORT_WEIGHTS)
                if (SPORT_WEIGHTS.hasOwnProperty(sportName)) {
                    showToast("Standard-Sportarten können nicht gelöscht werden.", "error");
                    return;
                }
                
                showDynamicModal(
                    "Sportart löschen",
                    `Möchten Sie die Sportart "${sportName}" wirklich unwiderruflich löschen? Zugehörige Einträge behalten die Minuten, aber verlieren ihre Gewichtung.`,
                    [
                        { id: 'confirm-yes-btn', text: 'Ja, löschen', class: 'bg-secondary text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition-colors', onClick: async () => {
                            const userSports = await getUserDefinedSports(userId);
                            delete userSports[sportName];
                            
                            // Speichere die neue Liste der benutzerdefinierten Sportarten in Firestore
                            await saveUserDefinedSports(userSports); 

                            // Lade alle Daten neu, um die UI zu aktualisieren
                            await loadAllData(); 
                            modal.classList.add('hidden');
                            showToast(`Sportart ${sportName} gelöscht.`, 'success');
                        }},
                        { id: 'confirm-no-btn', text: 'Nein', class: 'bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-500 transition-colors', onClick: () => modal.classList.add('hidden') }
                    ]
                );
            }

            // =====================================
            // Event-Listener Setup
            // =====================================
            
            function setupTimeframeListeners(entriesToUse) {
                 document.querySelectorAll('.timeframe-btn').forEach(btn => {
                    // Klonen, um sicherzustellen, dass nur ein Listener pro Button existiert
                    const button = btn.cloneNode(true);
                    btn.parentNode.replaceChild(button, btn);

                    button.addEventListener('click', async () => {
                        chartTimeframe = button.dataset.timeframe;
                        document.querySelectorAll('.timeframe-btn').forEach(b => {
                            const isSelected = b.dataset.timeframe === chartTimeframe;
                            b.classList.toggle('bg-primary', isSelected);
                            b.classList.toggle('hover:bg-blue-700', isSelected);
                            b.classList.toggle('bg-slate-600', !isSelected);
                            b.classList.toggle('hover:bg-slate-500', !isSelected);
                        });
                        
                        renderWeeklyProgressGraph(entriesToUse);
                    });
                    
                    // Setze den initialen Timeframe-Button-Status
                    const isSelected = button.dataset.timeframe === chartTimeframe;
                    button.classList.toggle('bg-primary', isSelected);
                    button.classList.toggle('hover:bg-blue-700', isSelected);
                    button.classList.toggle('bg-slate-600', !isSelected);
                    button.classList.toggle('hover:bg-slate-500', !isSelected);
                });
            }

            function setupEventListeners() {
                // Navigation
                document.querySelectorAll('.nav-button').forEach(btn => {
                    btn.addEventListener('click', () => showSection(btn.dataset.section));
                });
                // Collapsible
                setupCollapsibleListeners();

                // Forms
                document.getElementById('add-entry-form')?.addEventListener('submit', handleFormSubmit);
                document.getElementById('add-sport-form')?.addEventListener('submit', handleAddSportFormSubmit);

                // Entry Buttons (+5, +10, etc.)
                document.querySelector('#add-entry-section')?.addEventListener('click', (e) => {
                    const target = e.target;
                    const minutesInput = document.getElementById('minutes-input');
                    if (minutesInput && target.classList.contains('minutes-btn')) {
                        let currentMinutes = parseInt(minutesInput.value, 10);
                        currentMinutes += parseInt(target.dataset.minutes, 10);
                        minutesInput.value = currentMinutes;
                    } else if (target.id === 'clear-minutes-btn' && minutesInput) {
                        minutesInput.value = '0';
                    }
                });

                const sportSelect = document.getElementById('sport-select');
                if (sportSelect) {
                    sportSelect.addEventListener('change', () => {
                        const minutesInput = document.getElementById('minutes-input');
                        if(minutesInput) minutesInput.value = '0';
                    });
                }
                
                // Leaderboard Click Handling (delegiert)
                document.getElementById('leaderboard')?.addEventListener('click', (e) => {
                    const target = e.target.closest('[data-user-id]');
                    if (target) showUserProgress(target.dataset.userId);
                });
            }
            
            // =====================================
            // Formular-Handling
            // =====================================
            async function handleFormSubmit(e) {
                e.preventDefault();
                const sportSelect = document.getElementById('sport-select');
                const dateInput = document.getElementById('date-input');
                const minutesInput = document.getElementById('minutes-input');
                const sport = sportSelect.value;
                const date = dateInput.value;
                const minutes = parseInt(minutesInput.value, 10);

                if (minutes > 0 && date && userId && currentUser) {
                    // Hinzufügen einer Zeitverschiebung, um sicherzustellen, dass Firestore UTC korrekt speichert
                    const selectedDate = new Date(date);
                    selectedDate.setHours(12); // Setze auf Mittag, um Zeitzonenprobleme zu minimieren

                    const newEntry = {
                        userId: userId,
                        nickname: currentUser,
                        sport: sport,
                        minutes: minutes,
                        timestamp: selectedDate
                    };
                    
                    await addSportEntry(newEntry);
                    
                    minutesInput.value = '0';
                    showSection('dashboard');
                } else {
                    showDynamicModal("Ungültige Eingabe", "Bitte geben Sie eine positive Minutenzahl und ein Datum ein.", [{ id: 'modal-close-btn', text: 'OK', class: 'w-full bg-primary text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition-colors', onClick: () => modal.classList.add('hidden') }]);
                }
            }
            
            async function handleAddSportFormSubmit(e) {
                e.preventDefault();
                const newSportNameInput = document.getElementById('new-sport-name');
                const newSportWeightInput = document.getElementById('new-sport-weight');
                const sportName = newSportNameInput.value.trim();
                const sportWeight = parseFloat(newSportWeightInput.value);

                if (sportName && !isNaN(sportWeight) && sportWeight > 0) {
                    // Prüfen, ob die Sportart bereits existiert (entweder Standard oder benutzerdefiniert)
                    if (allSports.hasOwnProperty(sportName)) {
                        showToast("Diese Sportart existiert bereits.", "error");
                        return;
                    }

                    const userSports = await getUserDefinedSports(userId);
                    userSports[sportName] = sportWeight;
                    
                    await saveUserDefinedSports(userSports); // Speichert die aktualisierte Liste
                    
                    showToast("Sportart hinzugefügt!", "success");
                    newSportNameInput.value = '';
                    newSportWeightInput.value = '';
                    
                    await loadAllData();
                } else {
                    showDynamicModal("Ungültige Eingabe", "Bitte geben Sie einen gültigen Namen und eine positive Zahl für die Gewichtung ein.", [{ id: 'modal-close-btn', text: 'OK', class: 'w-full bg-primary text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition-colors', onClick: () => modal.classList.add('hidden') }]);
                }
            }
            
            // --- CRUD-Funktionen für Einträge ---
            function handleDeleteClick(docId) {
                showDynamicModal(
                    "Eintrag löschen",
                    "Möchten Sie diesen Eintrag wirklich unwiderruflich löschen?",
                    [
                        { id: 'confirm-yes-btn', text: 'Ja', class: 'bg-secondary text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition-colors', onClick: async () => {
                            await deleteSportEntry(docId);
                            modal.classList.add('hidden');
                        }},
                        { id: 'confirm-no-btn', text: 'Nein', class: 'bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-500 transition-colors', onClick: () => modal.classList.add('hidden') }
                    ]
                );
            }

            function handleEditClick(docId) {
                editingDocId = docId;
                const entriesToUse = (displayedUserId === userId) ? entries : (userEntriesCache[displayedUserId] || []);
                renderDashboardContent(entriesToUse);
            }

            async function handleSaveEdit(docId) {
                const editedSport = document.getElementById('edit-sport-select')?.value;
                const editedMinutes = parseInt(document.getElementById('edit-minutes-input')?.value);
                const editedDateString = document.getElementById('edit-date-input')?.value;

                if (editedMinutes > 0 && editedDateString) {
                    const editedDate = new Date(editedDateString);
                    editedDate.setHours(12); // Korrektur der Zeitzone

                    const newEntry = {
                        sport: editedSport,
                        minutes: editedMinutes,
                        timestamp: editedDate,
                    };
                    
                    await updateSportEntry(docId, newEntry);
                    
                    editingDocId = null;
                    const entriesToUse = (displayedUserId === userId) ? entries : (userEntriesCache[displayedUserId] || []);
                    renderDashboardContent(entriesToUse);
                } else {
                    showDynamicModal("Ungültige Eingabe", "Bitte geben Sie eine positive Minutenzahl und ein Datum ein.", [{ id: 'modal-close-btn', text: 'OK', class: 'w-full bg-primary text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition-colors', onClick: () => modal.classList.add('hidden') }]);
                }
            }

            function handleCancelEdit() {
                editingDocId = null;
                const entriesToUse = (displayedUserId === userId) ? entries : (userEntriesCache[displayedUserId] || []);
                renderDashboardContent(entriesToUse);
            }

            // =====================================
            // App-Initialisierung
            // =====================================
            async function migrateDataFromLocalStorage(firebaseUid) {
                appContainer.innerHTML = `<p class="text-center text-slate-400">Migriere lokale Daten...</p>`;
                
                const localStorageUserId = localStorage.getItem('userId');
                const localStorageNickname = localStorage.getItem('nickname');
                const sportEntriesStr = localStorage.getItem('sportEntries');
                
                if (!localStorageUserId || !localStorageNickname || !sportEntriesStr) {
                    console.warn("Lokalstorage-Daten fehlen. Migration wird übersprungen.");
                    await checkUserExistsAndLoad();
                    return;
                }

                try {
                    const entriesToMigrate = JSON.parse(sportEntriesStr).filter(entry => 
                        entry.userId === localStorageUserId && entry.nickname === localStorageNickname
                    );
                    
                    if (entriesToMigrate.length > 0) {
                        const leaderboardPath = `/artifacts/${appId}/public/data/leaderboard`;
                        await setDoc(doc(db, leaderboardPath, firebaseUid), { nickname: localStorageNickname, migratedFrom: localStorageUserId }, { merge: true });

                        const privateEntriesPath = `/artifacts/${appId}/users/${firebaseUid}/sportEntries`;
                        const batchPromises = entriesToMigrate.map(entry => {
                            const firestoreEntry = {
                                ...entry,
                                userId: firebaseUid,
                                nickname: localStorageNickname,
                                timestamp: new Date(entry.timestamp)
                            };
                            return addDoc(collection(db, privateEntriesPath), firestoreEntry);
                        });
                        await Promise.all(batchPromises);

                        const userDefinedSportsStr = localStorage.getItem('userDefinedSports');
                        if (userDefinedSportsStr) {
                            const sports = JSON.parse(userDefinedSportsStr);
                            const privateSportsPath = `/artifacts/${appId}/users/${firebaseUid}/userDefinedSports/sportsDoc`;
                            // Filtere Standard-Sportarten heraus, um nur Custom zu speichern
                            const customSportsOnly = Object.keys(sports).reduce((acc, key) => {
                                if (!SPORT_WEIGHTS.hasOwnProperty(key)) {
                                    acc[key] = sports[key];
                                }
                                return acc;
                            }, {});
                            await setDoc(doc(db, privateSportsPath), { sports: customSportsOnly });
                        }
                        
                        showToast("Lokale Daten erfolgreich migriert!", "success");
                    } else {
                        console.warn("Keine zu migrierenden Einträge für diesen Benutzer gefunden.");
                    }
                    
                    localStorage.removeItem('userId');
                    localStorage.removeItem('nickname');
                    localStorage.removeItem('sportEntries');
                    localStorage.removeItem('userDefinedSports');

                } catch (error) {
                    console.error("Fehler bei der Migration:", error);
                    showDynamicModal("Migrationsfehler", "Ein Fehler ist bei der Datenmigration aufgetreten. Bitte versuchen Sie es erneut.", [{ id: 'modal-close-btn', text: 'OK', class: 'w-full bg-primary text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition-colors', onClick: () => modal.classList.add('hidden') }]);
                }
                finally {
                    await loadAllData();
                }
            }

            async function checkUserExistsAndLoad() {
                const userDocRef = doc(db, `/artifacts/${appId}/public/data/leaderboard`, userId);
                try {
                    const userDoc = await getDoc(userDocRef);
                    if (userDoc.exists()) {
                        currentUser = userDoc.data().nickname;
                        await loadAllData();
                        renderApp();
                    } else {
                        renderNicknameForm();
                    }
                } catch (error) {
                    console.error("Fehler beim Laden der Benutzerdaten:", error);
                    showDynamicModal("Fehler", "Benutzerdaten konnten nicht geladen werden. Bitte versuchen Sie es erneut.", [{ id: 'modal-close-btn', text: 'OK', class: 'w-full bg-primary text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition-colors', onClick: () => modal.classList.add('hidden') }]);
                }
            }
            
            async function startApp() {
                if (!app) {
                    showConfigModal();
                    return;
                }

                if (!auth || !db) {
                    console.error("Firebase Auth oder Firestore Instanz nicht initialisiert.");
                    showDynamicModal("Initialisierungsfehler", "Firebase konnte nicht richtig geladen werden. Überprüfen Sie Ihre Konfiguration.", [{ id: 'modal-close-btn', text: 'OK', class: 'w-full bg-primary text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition-colors', onClick: () => modal.classList.add('hidden') }]);
                    return;
                }
                
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error('Authentifizierungsfehler:', error);
                    showDynamicModal("Authentifizierungsfehler", "Konnte mich nicht anmelden. Bitte überprüfen Sie Ihre Internetverbindung.", [{ id: 'modal-close-btn', text: 'OK', class: 'w-full bg-primary text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition-colors', onClick: () => modal.classList.add('hidden') }]);
                    return;
                }

                userId = auth.currentUser.uid;
                displayedUserId = userId;

                const hasLocalData = localStorage.getItem('userId') && localStorage.getItem('sportEntries');
                if (hasLocalData) {
                    await migrateDataFromLocalStorage(userId);
                } else {
                    await checkUserExistsAndLoad();
                }
            }

            startApp();
        })(); 
    </script>
</head>
<body class="p-4 sm:p-8">
    <!-- Hauptcontainer für die gesamte App -->
    <div class="bg-slate-800 p-6 sm:p-8 rounded-2xl shadow-xl w-full max-w-4xl mx-auto border border-slate-700 flex-grow">
        <h1 class="text-3xl sm:text-4xl font-bold text-center text-primary mb-2">Sport Challenge 2025/26</h1>
        <p class="text-center text-slate-400 mb-6">Ziel: 8000 Minuten Sport in einem Jahr.</p>

        <!-- Container für die Anmeldemaske oder die Haupt-App -->
        <div id="app-container">
            <p class="text-center text-slate-400">Lade App-Daten...</p>
        </div>
    </div>
    
    <!-- Modales Overlay für Warnungen/Meldungen -->
    <div id="message-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
        <div id="modal-content-wrapper" class="bg-slate-800 p-6 rounded-xl shadow-2xl max-w-sm w-full border border-slate-700">
        </div>
    </div>

    <!-- Toast Benachrichtigungs-Container -->
    <div id="toast-container" class="toast-container"></div>

    <!-- Footer Navigation -->
    <footer class="mt-8">
    </footer>
</body>
</html>
